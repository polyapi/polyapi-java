const axios = require('axios');

module.exports = function(eventsClientId, getSocket, clientId, clientSecret, {{#if audienceRequired}}audience, scopes, callback, { callbackUrl, timeout = 120000, autoCloseOnToken = true, userId } = {}{{else}}scopes, callback, { audience, callbackUrl, timeout = 120000, autoCloseOnToken = true, userId } = {}{{/if}}) {
  if (userId) {
    eventsClientId = `${eventsClientId}-${userId}`;
  }

  axios.post(`{{apiBaseUrl}}/auth-providers/{{id}}/execute`, { eventsClientId, clientId, clientSecret, scopes, audience, callbackUrl }, { headers: { 'X-PolyApiKey': '{{apiKey}}' }})
    .then(({ data }) => {
      if (data.token) {
        callback(data.token, data.url, data.error);
        return;
      }

      let timeoutID;
      const socket = getSocket();
      const unregisterEventHandler = () => {
        socket.off(`handleAuthFunctionEvent:{{id}}`);
        socket.emit('unregisterAuthFunctionEventHandler', {
            clientID: eventsClientId,
            functionId: '{{id}}',
            apiKey: '{{apiKey}}'
        });
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      };
      const handleEvent = ({ token, url, error }) => {
        callback(token, url, error);
        if (token && autoCloseOnToken) {
          unregisterEventHandler();
        }
      };
      socket.emit('registerAuthFunctionEventHandler', {
        clientID: eventsClientId,
        functionId: '{{id}}',
        apiKey: '{{apiKey}}'
      }, registered => {
        if (registered) {
          socket.on(`handleAuthFunctionEvent:{{id}}`, handleEvent);
          callback(data.token, data.url, data.error);
        }
      });

      if (timeout) {
        timeoutID = setTimeout(() => {
          unregisterEventHandler();
          callback(null, null, { message: 'Timeout reached' });
        }, timeout);
      }
    });

  return {
    revoke: () => axios.post(`{{apiBaseUrl}}/functions/auth/{{id}}/revoke`, { clientId, clientSecret }, { headers: { 'X-PolyApiKey': '{{apiKey}}' }}),
  };
}
